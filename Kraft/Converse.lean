/-
Copyright (c) 2026 Elazar Gershuni. All rights reserved.
Released under MIT license as described in the file LICENSE.
Authors: Elazar Gershuni
-/
import Mathlib.Data.List.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fintype.Card
import Mathlib.Algebra.BigOperators.Fin
import Mathlib.Algebra.BigOperators.Field
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.SpecificLimits.Normed

import Kraft.Basic
import Kraft.Digits
import Kraft.Helpers
import Kraft.ExtShift
import Kraft.KraftOrder
import Kraft.McMillan

/-!
# Constructive Converse of Kraft's Inequality

This file provides the constructive proof that for any monotone sequence of lengths satisfying
the Kraft condition, a prefix-free code with those lengths exists.

## Structure

1. **Construction Core (`Construction`)**:
   The algorithmic engine. It assumes the index is `ℕ` and the prefix sums are strictly `< 1`.
   It constructs integer intervals and converts them to base-`D` digits.

2. **Concrete Theorems (`Nat` and `Fin`)**:
   - **Infinite (`ℕ`)**: Reduces `∑' ≤ 1` to the strict prefix condition (since adding a term to a prefix ≥ 1 would exceed 1).
   - **Finite (`Fin k`)**: The most delicate case. A sum of *exactly* 1 cannot be extended to an infinite series
     without exceeding 1. We handle this by extending the lengths to `ℕ` (via `Kraft.ExtShift`),
     running the core engine, and restricting back to `Fin k`.

3. **General API (`General`)**:
   Wrappers that accept arbitrary index types (via equivalence to `ℕ` or `Fin k`) and arbitrary alphabets.

## Main Results

- `Kraft.Converse.exists_code_nat`: The converse for `l : ℕ → ℕ`.
- `Kraft.Converse.exists_code_fin`: The converse for `l : Fin k → ℕ`.
- `Kraft.Converse.exists_code`: The master theorem for arbitrary types.
-/

namespace Kraft.Converse

open scoped BigOperators Real
open Nat

variable {D : ℕ}

/-! ### 1. Construction Core
Logic for converting strict prefix bounds into valid prefix-free codes. -/

section Construction

/-- A sufficient condition for prefix-freeness based on the underlying integer values.
If two codes are generated by `natToDigitsBE`, they are prefix-free if their integer values
satisfy a specific separation property involving division. -/
private lemma prefixFree_of_div_separated {k : ℕ} {l : Fin k → ℕ} {A : ℕ → ℕ}
    (hD : 1 < D)
    (h_bound : ∀ i : Fin k, A i.val < D ^ l i)
    (h_sep : ∀ {i j : Fin k}, i ≠ j → ¬ (l i ≤ l j ∧ A j.val / D ^ (l j - l i) = A i.val)) :
    PrefixFree (Set.range (fun i : Fin k => Digits.natToDigitsBE D (A i.val) (l i) (by omega))) := by
  intro a ⟨i, qi⟩ b ⟨j, qj⟩ hpre
  by_cases hij : (i = j) <;> subst a b
  · subst i
    rfl
  · obtain ⟨hle, hdiv⟩ := (Digits.natToDigitsBE_prefix_iff_div hD (h_bound i) (h_bound j)).mp hpre
    exact (h_sep hij ⟨hle, hdiv⟩).elim

/-- **The Algorithm**: Given strictly bounded prefix sums, we construct the code.
This is the internal engine used by both finite and infinite theorems. -/
theorem exists_code_of_strict_prefix_sum
    (hD : 1 < D) (l : ℕ → ℕ) (h_mono : Monotone l)
    (h_prefix_lt_one : ∀ n, (∑ k < n, (1 / D : ℝ) ^ l k) < 1) :
    ∃ w : ℕ → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      (∀ i, (w i).length = l i) := by
  -- Construct the starting integers A
  let A := kraft_numerator D l
  have hA_strict : StrictMono A := strictMono_kraft_numerator hD
  have hA_bound : ∀ n, A n < D ^ l n := kraft_numerator_bound h_mono hD h_prefix_lt_one

  -- Define the code w using Base-D expansion
  let w (n : ℕ) := Digits.natToDigitsBE D (A n) (l n) hD
  refine ⟨w, ?_, ?_, ?_⟩

  -- Injectivity
  · intro n m hnm
    have hlen : l n = l m := by simpa [w, Digits.natToDigitsBE_length] using congrArg List.length hnm
    subst w
    simp at hnm
    -- rw [hlen] at hnm
    have : A n = A m := Digits.natToDigitsBE_inj hD (hA_bound n) (by simpa [hlen] using hA_bound m) (by rw [<-hlen] at hnm; exact hnm)
    exact hA_strict.injective this

  · -- Prefix-freeness
    intro a ha b hb hpre
    rcases ha with ⟨n, rfl⟩
    rcases hb with ⟨m, rfl⟩
    by_cases hnm : n = m
    · subst hnm
      rfl
    · -- turn prefix into the division characterization
      have hdiv :
          l n ≤ l m ∧ A m / D ^ (l m - l n) = A n :=
        (Digits.natToDigitsBE_prefix_iff_div hD (hA_bound n) (hA_bound m)).1 hpre

      rcases lt_or_gt_of_ne hnm with hlt | hgt
      · -- n < m: contradict the separation lemma for kraft_numerator
        exfalso
        have hdiv' :
            l n ≤ l m ∧
              kraft_numerator D l m / D ^ (l m - l n) = kraft_numerator D l n := by
          simpa [A] using hdiv
        exact (kraft_numerator_div_separated_of_lt (D := D) (l := l) hD h_mono hlt) hdiv'

      · -- n > m: force equal lengths, hence A m = A n, contradict StrictMono
        exfalso
        have hlen_le : l m ≤ l n := h_mono (Nat.le_of_lt hgt)
        have hlen_eq : l n = l m := le_antisymm hdiv.1 hlen_le

        have hAeq : A m = A n := by
          have : l m - l n = 0 := by simp [hlen_eq]
          -- hdiv.2 : A m / D^(l m - l n) = A n, and the exponent is 0
          simpa [this] using hdiv.2

        exact hnm ((hA_strict.injective hAeq).symm)

  -- Lengths
  · intro i
    simp [w, Digits.natToDigitsBE_length]

end Construction

/-! ### 2. Concrete Theorems (Nat & Fin)
Handling the "Sum ≤ 1" condition for specific index types. -/

section Nat

/-- The converse for **infinite** sequences (`ℕ`).
If `∑ D^{-l_i} ≤ 1`, then every finite prefix sum is strictly `< 1` (assuming positive terms),
allowing us to use the core construction. -/
theorem exists_code_nat
    (hD : 1 < D) (l : ℕ → ℕ) (h_mono : Monotone l)
    (h_summable : Summable (fun i => (1 / D : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / D : ℝ) ^ l i ≤ 1) :
    ∃ w : ℕ → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      (∀ i, (w i).length = l i) := by
  have h_pos : (0 : ℝ) < 1 / D := one_div_pos.mpr (by exact_mod_cast zero_lt_of_lt hD)

  -- Convert global "≤ 1" to strict prefix "< 1"
  -- similar to kraft_numerator_bound_of_tsum_le_one
  have h_prefix : ∀ n, (∑ k < n, (1 / D : ℝ) ^ l k) < 1 := by
    intro n
    have h_le_tsum : (∑ k ∈ Finset.range (n + 1), (1 / D : ℝ) ^ l k) ≤ ∑' k, (1 / D : ℝ) ^ l k :=
      Summable.sum_le_tsum _ (fun _ _ => by positivity) h_summable
    have h_le_one : (∑ k ∈ Finset.range (n + 1), (1 / D : ℝ) ^ l k) ≤ 1 :=
      le_trans h_le_tsum h_sum
    -- If a sum of (n+1) positive terms is ≤ 1, the sum of n terms is strictly < 1
    simpa [range_eq_Iio] using sum_range_lt_one_of_sum_range_le_one h_pos (lt_succ_self n) l h_le_one

  exact exists_code_of_strict_prefix_sum hD l h_mono h_prefix

end Nat

section Fin

/-- The converse for **finite** sequences (`Fin k`).
This handles the tight boundary case where `∑ = 1`. We cannot simply embed into `ℕ` and use
the infinite theorem because extending a sum of 1 with zeroes is impossible for `D > 1`.
Instead, we extend the length sequence to `ℕ` artificially, run the construction, and restrict back. -/
theorem exists_code_fin
    (hD : 1 < D) {k : ℕ}
    (l : Fin k → ℕ) (h_mono : Monotone l)
    (h_sum : (∑ i, (1 / D : ℝ) ^ l i) ≤ 1) :
    ∃ w : Fin k → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  by_cases hk : k = 0
  · subst k
    refine ⟨fun i => Fin.elim0 i, fun i => Fin.elim0 i, fun _ ⟨i, _⟩ _ _ => Fin.elim0 i, fun i => Fin.elim0 i⟩

  -- 1. Extend l to lNat on ℕ
  let Llast := l ⟨k - 1, by omega⟩
  let lNat := ext_shift Llast 0 l
  have hmonoNat : Monotone lNat := ext_shift_monotone k l h_mono hk 0

  -- 2. Construct A on ℕ
  let A := kraft_numerator D lNat
  have hA_strict : StrictMono A := strictMono_kraft_numerator hD

  -- 3. Verify bounds for indices < k
  -- fin k version of kraft_numerator_bound
  have hA_bound : ∀ i : Fin k, A i.val < D ^ l i := by
    intro i
    -- Map Fin sum to range sum
    have h_sum_range : (∑ t ∈ Finset.range k, (1 / (D : ℝ)) ^ lNat t) ≤ 1 := by
      convert h_sum using 1
      rw [<-Fin.sum_univ_eq_sum_range (fun t => (1 / (D : ℝ)) ^ lNat t)]
      apply Finset.sum_congr rfl
      intro x hx
      simp [lNat]
    -- Strict prefix logic
    have h_pos : (0 : ℝ) < 1 / D := one_div_pos.mpr (by exact_mod_cast zero_lt_of_lt hD)
    have h_pref_lt1 : (∑ t ∈ Finset.range i.val, (1 / D : ℝ) ^ lNat t) < 1 :=
      sum_range_lt_one_of_sum_range_le_one h_pos i.isLt lNat h_sum_range
    -- Result for lNat, then rewrite to l
    have := kraft_numerator_lt_pow_of_sum_range_lt_one _ hD lNat hmonoNat h_pref_lt1
    have this' : kraft_numerator D lNat i.val < D ^ lNat i.val :=
      kraft_numerator_lt_pow_of_sum_range_lt_one
        (D := D) (hD := hD) (lNat := lNat) (hmono := hmonoNat)
        (n := i.val) (h_sum_lt1 := h_pref_lt1)

    -- rewrite `A` and `lNat i.val`
    simpa [A, lNat, ext_shift, i.isLt] using this'

  -- 4. Define code
  let w (i : Fin k) := Digits.natToDigitsBE D (A i.val) (l i) (by omega)
  refine ⟨w, ?_, ?_, ?_⟩

  -- Injectivity
  · intro i j hij
    apply Fin.ext
    have hlen : l i = l j := by simpa [w] using congrArg List.length hij
    subst w
    simp at hij
    -- A i = A j via digit injectivity
    have hA_eq : A i.val = A j.val := Digits.natToDigitsBE_inj hD (hA_bound i) (by simpa [hlen] using hA_bound j) (by rw [<-hlen] at hij; exact hij)
    exact hA_strict.injective hA_eq

  -- Prefix-freeness
  · suffices PrefixFree (Set.range (fun i : Fin k => Digits.natToDigitsBE D (A i.val) (l i) (by omega))) by
      simpa [w] using this
    refine prefixFree_of_div_separated hD hA_bound ?_
    intro i j hij
    -- Reduce to separation on ℕ
    rcases lt_trichotomy i.val j.val with hlt | heq | hgt
    · -- i.val < j.val
      have hsep :
        ¬ (lNat i.val ≤ lNat j.val ∧
            A j.val / D ^ (lNat j.val - lNat i.val) = A i.val) :=
        kraft_numerator_div_separated_of_lt
          (D := D) (l := lNat) (hmono := hmonoNat) (hD := hD) hlt

      simpa [lNat, ext_shift, i.isLt, j.isLt] using hsep
    · exact (hij (Fin.ext heq)).elim
    · -- i > j (swapped case)
      intro ⟨hle, hdiv⟩
      -- If l i ≤ l j and l j ≤ l i (by mono), lengths are eq.
      have h_len_eq : l i = l j := le_antisymm hle (h_mono (le_of_lt (Fin.lt_def.mp hgt)))
      -- Division becomes A j = A i, strict mono contradiction
      have : A j.val = A i.val := by simpa [h_len_eq] using hdiv
      exact (Nat.ne_of_gt hgt) (hA_strict.injective this.symm)

  -- Lengths
  · intro i
    simp [w]

end Fin

/-! ### 3. General API
Theorems for arbitrary alphabets and index types. -/

section General

variable {α I : Type _}

/-- **Converse of Kraft's Inequality** (General).
For any index set `I`, finite alphabet `α` (`|α| ≥ 2`), and length function `l : I → ℕ`.
If `∑ |α|^{-l i} ≤ 1`, there exists an injective prefix-free code. -/
theorem exists_code [Fintype α] [Nontrivial α]
    (l : I → ℕ)
    (h_summable : Summable (fun i ↦ (1 / Fintype.card α : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / Fintype.card α : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List α,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  let D := Fintype.card α
  have hD : 1 < D := Fintype.one_lt_card

  by_cases h_finite : Finite I
  · -- Finite Case
    haveI := Fintype.ofFinite I
    obtain ⟨e, he_mono⟩ := exists_equiv_fin_monotone l
    -- Transfer sum condition to Fin
    have h_sum_fin : ∑ i, (1 / D : ℝ) ^ l (e i) ≤ 1 := by
      convert h_sum using 1
      rw [tsum_fintype, ← Equiv.sum_comp e]
    -- Get code over Fin D
    obtain ⟨w_fin, h1, h2, h3⟩ := exists_code_fin hD (l ∘ e) he_mono h_sum_fin
    -- Map Fin D to α and shuffle indices
    let map_alpha := (Fintype.equivFin α).symm
    refine ⟨fun i => (w_fin (e.symm i)).map map_alpha, ?_, ?_, ?_⟩
    · -- Injectivity
      intro x y h
      apply e.symm.injective
      apply h1
      exact List.map_injective_iff.mpr map_alpha.injective h
    · -- Prefix Free
      intro a ha b hb hpre
      obtain ⟨x, rfl⟩ := ha; obtain ⟨y, rfl⟩ := hb
      simp only [Function.comp_apply] at *
      rw [List.IsPrefix.map_iff map_alpha.injective] at hpre
      have := h2 (w_fin (e.symm x)) ⟨_, rfl⟩ (w_fin (e.symm y)) ⟨_, rfl⟩ hpre
      simp [this]
    · intro i; simp [h3]

  · -- Infinite Case
    haveI : Infinite I := not_finite_iff_infinite.mp h_finite
    obtain ⟨e, he_mono⟩ := exists_equiv_nat_monotone_of_infinite D hD l h_summable
    -- Transfer sum condition to Nat
    have h_sum_nat : ∑' i : ℕ, (1 / D : ℝ) ^ l (e i) ≤ 1 := by
      convert h_sum using 1
      rw [← Equiv.tsum_eq e]
    -- Get code over Fin D
    obtain ⟨w_nat, h1, h2, h3⟩ := exists_code_nat hD (l ∘ e) he_mono (h_summable.comp_injective e.injective) h_sum_nat
    -- Map Fin D to α and shuffle indices
    let map_alpha := (Fintype.equivFin α).symm
    refine ⟨fun i => (w_nat (e.symm i)).map map_alpha, ?_, ?_, ?_⟩
    · -- Injectivity
      intro x y h
      apply e.symm.injective
      apply h1
      exact List.map_injective_iff.mpr map_alpha.injective h
    · -- Prefix Free
      intro a ha b hb hpre
      obtain ⟨x, rfl⟩ := ha; obtain ⟨y, rfl⟩ := hb
      rw [List.IsPrefix.map_iff map_alpha.injective] at hpre
      have := h2 (w_nat (e.symm x)) ⟨_, rfl⟩ (w_nat (e.symm y)) ⟨_, rfl⟩ hpre
      simp [this]
    · intro i
      simp [h3]

/-- **Converse of Kraft's Inequality** (General Arity Embedding).
Useful if you want to embed a code of arity `D` into a larger alphabet `α`. -/
theorem exists_code_of_embedding [DecidableEq α]
    {D : ℕ} (hD : 1 < D)
    (ι : Fin D ↪ α)
    (l : I → ℕ)
    (h_summable : Summable (fun i => (1 / D : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / D : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List α,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  -- Use a dummy type with cardinality D to generate the code structure
  let AlphaD := Fin D

  -- Pin down the cardinality explicitly
  have hcard_eq : Fintype.card AlphaD = D := by
    exact (Fintype.card_fin D)

  -- card AlphaD = D, so transport hD / summability / tsum bound
  have hcard : 1 < Fintype.card AlphaD := by simpa [hcard_eq] using hD

  haveI : Nontrivial AlphaD := (Fintype.one_lt_card_iff_nontrivial).1 hcard

  have h_summable' :
      Summable (fun i => (1 / (Fintype.card AlphaD : ℝ)) ^ l i) := by
    simpa [hcard_eq] using h_summable

  have h_sum' :
      (∑' i, (1 / (Fintype.card AlphaD : ℝ)) ^ l i) ≤ 1 := by
    simpa [hcard_eq] using h_sum

  obtain ⟨w_D, h1, h2, h3⟩ := exists_code l h_summable' h_sum'

  -- Embed results
  refine ⟨fun i => (w_D i).map ι, ?_, ?_, ?_⟩
  · intro x y h; apply h1; exact List.map_injective_iff.mpr ι.injective h
  · -- PrefixFree
    intro a ha b hb hpre
    rcases ha with ⟨x, rfl⟩
    rcases hb with ⟨y, rfl⟩
    -- now goal is: map ι (w_D x) = map ι (w_D y)

    have hpre' : w_D x <+: w_D y := by
      exact (List.IsPrefix.map_iff ι.injective).1 hpre

    have hxy : w_D x = w_D y :=
      h2 (w_D x) ⟨x, rfl⟩ (w_D y) ⟨y, rfl⟩ hpre'

    -- finish
    simp [hxy]
  · intro i
    simp [h3]

/-- **Converse of Kraft's Inequality** (Binary). -/
theorem exists_code_binary
    (l : I → ℕ)
    (h_summable : Summable (fun i ↦ (1 / 2 : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / 2 : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List Bool,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  let ι : Fin 2 ↪ Bool := ⟨(Fintype.equivFin Bool).symm, (Fintype.equivFin Bool).symm.injective⟩
  exact exists_code_of_embedding (by decide) ι l h_summable h_sum

end General

end Kraft.Converse
