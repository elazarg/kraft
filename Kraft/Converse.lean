/-
Copyright (c) 2026 Elazar Gershuni. All rights reserved.
Released under MIT license as described in the file LICENSE.
Authors: Elazar Gershuni
-/
import Mathlib.Data.List.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fintype.Card
import Mathlib.Algebra.BigOperators.Fin
import Mathlib.Algebra.BigOperators.Field
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.SpecificLimits.Normed

import Kraft.Basic
import Kraft.Codeword
import Kraft.Construction
import Kraft.ExtShift
import Kraft.Helpers
import Kraft.McMillan

/-!
# Constructive Converse of Kraft's Inequality

This file provides the constructive proof that for any monotone sequence of lengths satisfying
the Kraft condition, a prefix-free code with those lengths exists.

## Structure

1. **Construction Core (`Construction`)**:
   The algorithmic engine. It assumes the index is `ℕ` and the prefix sums are strictly `< 1`.
   It constructs integer intervals and converts them to base-`D` digits.

2. **Concrete Theorems (`Nat` and `Fin`)**:
   - **Infinite (`ℕ`)**: Reduces `∑' ≤ 1` to the strict prefix condition (since adding a term to a prefix ≥ 1 would exceed 1).
   - **Finite (`Fin k`)**: The most delicate case. A sum of *exactly* 1 cannot be extended to an infinite series
     without exceeding 1. We handle this by extending the lengths to `ℕ` (via `Kraft.ExtShift`),
     running the core engine, and restricting back to `Fin k`.

3. **General API (`General`)**:
   Wrappers that accept arbitrary index types (via equivalence to `ℕ` or `Fin k`) and arbitrary alphabets.

## Main Results

- `Kraft.Converse.exists_code_nat`: The converse for `l : ℕ → ℕ`.
- `Kraft.Converse.exists_code_fin`: The converse for `l : Fin k → ℕ`.
- `Kraft.Converse.exists_code`: The master theorem for arbitrary types.
-/

namespace Kraft.Converse

open scoped BigOperators Real
open Nat

variable {D : ℕ}

/-! ### 1. Construction Core
Logic for converting strict prefix bounds into valid prefix-free codes. -/

section Construction

lemma kraftCodeword_injective_of_A_injective
    {I : Type _} {l : I → ℕ} {A : I → ℕ}
    (hD : 1 < D)
    (hA_bound : ∀ i, A i < D ^ l i)
    (hA_inj : Function.Injective A) :
    Function.Injective (fun i : I => kraftCodeword hD (A i) (l i)) := by
  intro i j hij
  have hlen : l i = l j := by
    simpa using congrArg List.length hij
  have hA_eq : A i = A j := by
    refine kraftCodeword_inj hD (hA_bound i) ?_ ?_
    · simpa [hlen] using hA_bound j
    · simpa [hlen] using hij
  exact hA_inj hA_eq

/-- A sufficient condition for prefix-freeness based on the underlying integer values.
If two codes are generated by `kraftCodeword`, they are prefix-free if their integer values
satisfy a specific separation property involving division. -/
private lemma prefixFree_of_div_separated
    {I : Type _} [DecidableEq I]
    {l : I → ℕ} {A : I → ℕ}
    (hD : 1 < D)
    (h_bound : ∀ i, A i < D ^ l i)
    (h_sep : ∀ {i j}, i ≠ j → ¬ (l i ≤ l j ∧ A j / D ^ (l j - l i) = A i)) :
    PrefixFree (Set.range (fun i : I => kraftCodeword hD (A i) (l i))) := by
  intro x hx y hy hpre
  rcases hx with ⟨i, rfl⟩
  rcases hy with ⟨j, rfl⟩
  by_cases hij : i = j
  · subst hij
    rfl
  · obtain ⟨hle, hdiv⟩ :=
      (kraftCodeword_prefix_iff_div hD (h_bound i) (h_bound j)).1 hpre
    exact (h_sep hij ⟨hle, hdiv⟩).elim

theorem exists_code_from_A
    {I : Type _} [DecidableEq I]
    (hD : 1 < D)
    {l : I → ℕ} {A : I → ℕ}
    (hA_bound : ∀ i, A i < D ^ l i)
    (hA_inj : Function.Injective A)
    (h_sep : ∀ {i j}, i ≠ j → ¬ (l i ≤ l j ∧ A j / D ^ (l j - l i) = A i)) :
    ∃ w : I → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  let w : I → List (Fin D) := fun i => kraftCodeword hD (A i) (l i)
  refine ⟨w, ?_, ?_, ?_⟩ <;> simp [w]
  · simpa using (kraftCodeword_injective_of_A_injective hD hA_bound hA_inj)
  · simpa using (prefixFree_of_div_separated hD hA_bound h_sep)

/-- **The Algorithm**: Given strictly bounded prefix sums, we construct the code.
This is the internal engine used by both finite and infinite theorems. -/
theorem exists_code_of_strict_prefix_sum
    (hD : 1 < D) {l : ℕ → ℕ} (h_mono : Monotone l)
    (h_prefix_lt_one : ∀ n, (∑ k < n, (1 / D : ℝ) ^ l k) < 1) :
    ∃ w : ℕ → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      (∀ i, (w i).length = l i) := by
  -- define A and basic facts
  let A : ℕ → ℕ := kraftNumerator D l
  have hA_strict : StrictMono A := by simpa [A] using kraftNumerator.strictMono (D := D) hD
  have hA_bound : ∀ i, A i < D ^ l i := by
    simpa [A] using kraftNumerator.bound (D := D) (l := l) h_mono hD h_prefix_lt_one
  have hA_inj : Function.Injective A := hA_strict.injective

  -- separation for all i≠j
  have h_sep : ∀ {i j : ℕ}, i ≠ j →
      ¬ (l i ≤ l j ∧ A j / D ^ (l j - l i) = A i) := by
    intro i j hij
    rcases lt_or_gt_of_ne hij with hlt | hgt
    · -- forward direction is exactly the lemma you already proved
      simpa [A] using (kraftNumerator.div_separated_of_lt (D := D) (l := l) hD h_mono hlt)
    · -- backward direction: monotonicity forces equal lengths, then strictMono contradicts i≠j
      rintro ⟨hle, hdiv⟩
      have hlen_le : l j ≤ l i := h_mono (Nat.le_of_lt hgt)
      have hlen_eq : l i = l j := le_antisymm hle hlen_le
      have : A j = A i := by
        have : l j - l i = 0 := by simp [hlen_eq]
        -- from hdiv: A j / D^0 = A i
        simpa [this] using hdiv
      exact (Nat.ne_of_gt hgt) (hA_strict.injective this.symm)

  -- done: one call builds w + injective + prefixfree + lengths
  simpa [A] using exists_code_from_A hD hA_bound hA_inj h_sep

end Construction

/-! ### 2. Concrete Theorems (Nat & Fin)
Handling the "Sum ≤ 1" condition for specific index types. -/

section Nat

/-- The converse for **infinite** sequences (`ℕ`).
If `∑ D^{-l_i} ≤ 1`, then every finite prefix sum is strictly `< 1` (assuming positive terms),
allowing us to use the core construction. -/
theorem exists_code_nat
    (hD : 1 < D) {l : ℕ → ℕ} (h_mono : Monotone l)
    (h_summable : Summable (fun i => (1 / D : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / D : ℝ) ^ l i ≤ 1) :
    ∃ w : ℕ → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      (∀ i, (w i).length = l i) := by
  have h_pos : (0 : ℝ) < 1 / D := one_div_pos.mpr (by exact_mod_cast zero_lt_of_lt hD)

  have h_prefix := strict_prefix_of_tsum_le_one hD h_summable h_sum

  exact exists_code_of_strict_prefix_sum hD h_mono h_prefix

end Nat

section Fin

/-- The converse for **finite** sequences (`Fin k`).
This handles the tight boundary case where `∑ = 1`. We cannot simply embed into `ℕ` and use
the infinite theorem because extending a sum of 1 with zeroes is impossible for `D > 1`.
Instead, we extend the length sequence to `ℕ` artificially, run the construction, and restrict back. -/
theorem exists_code_fin
    (hD : 1 < D) {k : ℕ}
    {l : Fin k → ℕ} (h_mono : Monotone l)
    (h_sum : (∑ i, (1 / D : ℝ) ^ l i) ≤ 1) :
    ∃ w : Fin k → List (Fin D),
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  by_cases hk : k = 0
  · subst k
    refine ⟨?_, ?_, ?_, ?_⟩ <;> try (exact fun x => Fin.elim0 x)
    · intro a ⟨i, _⟩ _ ⟨j, _⟩
      exact Fin.elim0 i

  -- 1) extend lengths to ℕ
  let Llast := l ⟨k - 1, by omega⟩
  let lNat := ext_shift Llast 0 l
  have hmonoNat : Monotone lNat := ext_shift_monotone k l h_mono hk 0
  have h_sumNat : (∑ i : Fin k, (1 / D : ℝ) ^ lNat i.val) ≤ 1 := by
    simpa [lNat] using h_sum

  -- 2) define A0 on ℕ and restrict it to Fin k
  let A0 : ℕ → ℕ := kraftNumerator D lNat
  have hA0_strict : StrictMono A0 := by
    simpa [A0] using (kraftNumerator.strictMono (l:=lNat) hD)

  let AFin : Fin k → ℕ := fun i => A0 i.val

  -- 3) bound on AFin
  have hAFin_bound : ∀ i : Fin k, AFin i < D ^ l i := by
    intro i
    have h_pref_lt1 :
        (∑ t ∈ Finset.range i.val, (1 / D : ℝ) ^ lNat t) < 1 :=
      prefix_sum_lt_one_of_fin_sum_le_one hD h_sumNat i
    -- this gives: A0 i.val < D ^ lNat i.val; rewrite lNat i.val = l i
    simpa [AFin, A0, lNat] using
      (kraftNumerator.lt_pow_of_sum_range_lt_one hD hmonoNat h_pref_lt1)

  -- 4) injectivity of AFin
  have hAFin_inj : Function.Injective AFin := by
    intro i j hij
    apply Fin.ext
    exact hA0_strict.injective hij

  -- 5) separation on Fin k, reduced to the ℕ separation lemma
  have hAFin_sep :
      ∀ {i j : Fin k}, i ≠ j →
        ¬ (l i ≤ l j ∧ AFin j / D ^ (l j - l i) = AFin i) := by
    intro i j hij
    rcases lt_trichotomy i.val j.val with hlt | heq | hgt
    · -- i.val < j.val: use separation on ℕ for A0 = kraftNumerator D lNat
      have hsepNat :
          ¬ (lNat i.val ≤ lNat j.val ∧
              A0 j.val / D ^ (lNat j.val - lNat i.val) = A0 i.val) :=
        kraftNumerator.div_separated_of_lt (D:=D) (l:=lNat) hD hmonoNat hlt
      -- rewrite lNat back to l on indices < k, and AFin/A0
      simpa [AFin, A0, lNat, ext_shift, i.isLt, j.isLt] using hsepNat
    · exact (hij (Fin.ext heq)).elim
    · -- i.val > j.val: monotone forces equal lengths, then strictMono contradicts i≠j
      rintro ⟨hle, hdiv⟩
      have hjle : j ≤ i := le_of_lt (Fin.lt_def.2 hgt)
      have hlen_le : l j ≤ l i := h_mono hjle
      have hlen_eq : l i = l j := le_antisymm hle hlen_le
      have : AFin j = AFin i := by
        -- hdiv : AFin j / D^(l j - l i) = AFin i, but l j - l i = 0
        have : l j - l i = 0 := by simp [hlen_eq]
        simpa [this] using hdiv
      exact (Nat.ne_of_lt hgt) (hA0_strict.injective this)

  -- 6) single call builds w + inj + prefixfree + lengths
  simpa [AFin] using
    (exists_code_from_A hD hAFin_bound hAFin_inj (by
        intro i j hij
        exact hAFin_sep hij))

end Fin

/-! ### 3. General API
Theorems for arbitrary alphabets and index types. -/

section General

variable {α I : Type _}

/-- **Converse of Kraft's Inequality** (General).
For any index set `I`, finite alphabet `α` (`|α| ≥ 2`), and length function `l : I → ℕ`.
If `∑ |α|^{-l i} ≤ 1`, there exists an injective prefix-free code. -/
theorem exists_code [Fintype α] [Nontrivial α]
    (l : I → ℕ)
    (h_summable : Summable (fun i ↦ (1 / Fintype.card α : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / Fintype.card α : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List α,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  let D := Fintype.card α
  have hD : 1 < D := Fintype.one_lt_card

  by_cases h_finite : Finite I
  · -- Finite Case
    haveI := Fintype.ofFinite I
    obtain ⟨e, he_mono⟩ := exists_equiv_fin_monotone l
    -- Transfer sum condition to Fin
    have h_sum_fin : ∑ i, (1 / D : ℝ) ^ l (e i) ≤ 1 := by
      convert h_sum using 1
      rw [tsum_fintype, ← Equiv.sum_comp e]
    -- Get code over Fin D
    obtain ⟨w_fin, h1, h2, h3⟩ := exists_code_fin hD he_mono h_sum_fin
    -- Map Fin D to α and shuffle indices
    let map_alpha := (Fintype.equivFin α).symm
    refine ⟨fun i => (w_fin (e.symm i)).map map_alpha, ?_, ?_, ?_⟩
    · -- Injectivity
      intro x y h
      apply e.symm.injective
      apply h1
      exact List.map_injective_iff.mpr map_alpha.injective h
    · -- Prefix Free
      intro a ha b hb hpre
      obtain ⟨x, rfl⟩ := ha; obtain ⟨y, rfl⟩ := hb
      simp only [Function.comp_apply] at *
      rw [List.IsPrefix.map_iff map_alpha.injective] at hpre
      have := h2 (w_fin (e.symm x)) ⟨_, rfl⟩ (w_fin (e.symm y)) ⟨_, rfl⟩ hpre
      simp [this]
    · intro i; simp [h3]

  · -- Infinite Case
    haveI : Infinite I := not_finite_iff_infinite.mp h_finite
    obtain ⟨e, he_mono⟩ := exists_equiv_nat_monotone_of_infinite D hD l h_summable
    -- Transfer sum condition to Nat
    have h_sum_nat : ∑' i : ℕ, (1 / D : ℝ) ^ l (e i) ≤ 1 := by
      convert h_sum using 1
      rw [← Equiv.tsum_eq e]
    -- Get code over Fin D
    obtain ⟨w_nat, h1, h2, h3⟩ := exists_code_nat hD he_mono (h_summable.comp_injective e.injective) h_sum_nat
    -- Map Fin D to α and shuffle indices
    let map_alpha := (Fintype.equivFin α).symm
    refine ⟨fun i => (w_nat (e.symm i)).map map_alpha, ?_, ?_, ?_⟩
    · -- Injectivity
      intro x y h
      apply e.symm.injective
      apply h1
      exact List.map_injective_iff.mpr map_alpha.injective h
    · -- Prefix Free
      intro a ha b hb hpre
      obtain ⟨x, rfl⟩ := ha; obtain ⟨y, rfl⟩ := hb
      rw [List.IsPrefix.map_iff map_alpha.injective] at hpre
      have := h2 (w_nat (e.symm x)) ⟨_, rfl⟩ (w_nat (e.symm y)) ⟨_, rfl⟩ hpre
      simp [this]
    · intro i
      simp [h3]

lemma transport_code
    {I J α β : Type _}
    (e : I ≃ J)
    (f : α ↪ β)
    {w : I → List α}
    (hw_inj : Function.Injective w)
    (hw_pf : PrefixFree (Set.range w)) :
    Function.Injective (fun j : J => (w (e.symm j)).map f) ∧
      PrefixFree (Set.range (fun j : J => (w (e.symm j)).map f)) := by
  constructor
  · -- Injective
    intro j1 j2 hj
    -- cancel `List.map f`
    have hw : w (e.symm j1) = w (e.symm j2) :=
      (List.map_injective_iff.mpr f.injective) hj
    -- cancel `w`
    have he : e.symm j1 = e.symm j2 := hw_inj hw
    -- cancel `e.symm`
    exact e.symm.injective he

  · -- PrefixFree
    intro x hx y hy hpre
    rcases hx with ⟨j1, rfl⟩
    rcases hy with ⟨j2, rfl⟩
    -- pull prefix back through `map f`
    have hpre' : w (e.symm j1) <+: w (e.symm j2) :=
      (List.IsPrefix.map_iff f.injective).1 hpre
    -- apply prefix-freeness of the original range
    have hw_eq : w (e.symm j1) = w (e.symm j2) :=
      hw_pf _ ⟨e.symm j1, rfl⟩ _ ⟨e.symm j2, rfl⟩ hpre'
    -- push equality forward
    simp [hw_eq]

/-- **Converse of Kraft's Inequality** (General Arity Embedding).
Useful if you want to embed a code of arity `D` into a larger alphabet `α`. -/
theorem exists_code_of_embedding [DecidableEq α]
    {D : ℕ} (hD : 1 < D)
    (ι : Fin D ↪ α)
    {l : I → ℕ}
    (h_summable : Summable (fun i => (1 / D : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / D : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List α,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  -- Use a dummy type with cardinality D to generate the code structure
  let AlphaD := Fin D

  -- Pin down the cardinality explicitly
  have hcard_eq : Fintype.card AlphaD = D := by
    exact (Fintype.card_fin D)

  -- card AlphaD = D, so transport hD / summability / tsum bound
  have hcard : 1 < Fintype.card AlphaD := by simpa [hcard_eq] using hD

  haveI : Nontrivial AlphaD := (Fintype.one_lt_card_iff_nontrivial).1 hcard

  have h_summable' :
      Summable (fun i => (1 / (Fintype.card AlphaD : ℝ)) ^ l i) := by
    simpa [hcard_eq] using h_summable

  have h_sum' :
      (∑' i, (1 / (Fintype.card AlphaD : ℝ)) ^ l i) ≤ 1 := by
    simpa [hcard_eq] using h_sum

  obtain ⟨w_D, h1, h2, h3⟩ := exists_code l h_summable' h_sum'

  -- Embed results
  refine ⟨fun i => (w_D i).map ι, ?_, ?_, ?_⟩
  · intro x y h; apply h1; exact List.map_injective_iff.mpr ι.injective h
  · -- PrefixFree
    intro a ha b hb hpre
    rcases ha with ⟨x, rfl⟩
    rcases hb with ⟨y, rfl⟩
    -- now goal is: map ι (w_D x) = map ι (w_D y)

    have hpre' : w_D x <+: w_D y := by
      exact (List.IsPrefix.map_iff ι.injective).1 hpre

    have hxy : w_D x = w_D y :=
      h2 (w_D x) ⟨x, rfl⟩ (w_D y) ⟨y, rfl⟩ hpre'

    -- finish
    simp [hxy]
  · intro i
    simp [h3]

/-- **Converse of Kraft's Inequality** (Binary). -/
theorem exists_code_binary
    (l : I → ℕ)
    (h_summable : Summable (fun i ↦ (1 / 2 : ℝ) ^ l i))
    (h_sum : ∑' i, (1 / 2 : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List Bool,
      Function.Injective w ∧
      PrefixFree (Set.range w) ∧
      ∀ i, (w i).length = l i := by
  let ι : Fin 2 ↪ Bool := ⟨(Fintype.equivFin Bool).symm, (Fintype.equivFin Bool).symm.injective⟩
  exact exists_code_of_embedding (by decide) ι h_summable h_sum

end General

end Kraft.Converse
