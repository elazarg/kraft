/-
This file was generated by Aristotle.
Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 77df72b1-85d7-47ad-85f6-4657787e8a9c
Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/
import Mathlib
set_option linter.mathlibStandardSet false
open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise
set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128
set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
If $S$ is a finite prefix-free code then $\sum_{w \in S} 2^{-|w|} \leq 1$.
-/
def PrefixFree (S : Set (List Bool)) : Prop :=
  ∀ x ∈ S, ∀ y ∈ S, x <+: y → x = y

theorem kraft_inequality (S : Finset (List Bool)) (h : PrefixFree S) :
    ∑ w ∈ S, (1 / 2 : ℝ) ^ w.length ≤ 1 := by

  -- Let $n$ be the maximum length of a word in $S$.
  let n := Finset.sup S List.length

  -- The set of all boolean strings of length k
  let all_words (k : ℕ) : Finset (List Bool) :=
    (Finset.univ : Finset (Fin k → Bool)).image List.ofFn

  -- The "cylinder" of w (all extensions of w to length n)
  let cylinder (w : List Bool) : Finset (List Bool) :=
    (all_words (n - w.length)).image (w ++ ·)

  -- Helper: A list is in 'all_words k' iff its length is k
  have mem_all_words_iff (k : ℕ) (l : List Bool) : l ∈ all_words k ↔ l.length = k := by
    rw [Finset.mem_image]
    constructor
    · rintro ⟨f, _, rfl⟩
      simp
    · intro hlen
      -- If length is k, it comes from the function `l.get`
      exists (fun i => l.get ⟨i, hlen.symm ▸ i.isLt⟩)
      simp only [Finset.mem_univ, true_and]
      apply List.ext_get
      · simp [hlen]
      · intro i h1 h2
        simp

  -- 2. Disjointness: Cylinders don't overlap because S is prefix-free.
  have h_disjoint : ∀ w1 ∈ S, ∀ w2 ∈ S, w1 ≠ w2 → Disjoint (cylinder w1) (cylinder w2) := by
    intros w1 hw1 w2 hw2 hne
    rw [Finset.disjoint_left]
    intro x hx1 hx2
    rcases Finset.mem_image.mp hx1 with ⟨s1, _, rfl⟩
    rcases Finset.mem_image.mp hx2 with ⟨s2, _, heq⟩
    rw [List.append_eq_append_iff] at heq
    rcases heq with ⟨m, rfl, -⟩ | ⟨m, rfl, -⟩
    · exact hne (h w2 hw2 _ hw1 ⟨m, rfl⟩).symm
    · exact hne (h w1 hw1 _ hw2 ⟨m, rfl⟩)

  -- card of all_words
  have all_words_card (k : ℕ) : (all_words k).card = 2^k := by
    -- all_words k = image List.ofFn univ, and List.ofFn is injective
    have hinj : Function.Injective (List.ofFn : (Fin k → Bool) → List Bool) := by
      intro f g hfg
      -- this lemma exists in Lean4/Mathlib
      exact List.ofFn_injective hfg
    -- card(image) = card(univ) = 2^k
    simp [all_words, Finset.card_image_of_injective, hinj]

  -- card of each cylinder
  have cylinder_card (w : List Bool) : (cylinder w).card = 2^(n - w.length) := by
    have hinj : Function.Injective (fun z : List Bool => w ++ z) := by
      intro a b hab
      simp_all
    -- cylinder w = image (w++·) (all_words (n - |w|))
    simp [cylinder, Finset.card_image_of_injective, hinj, all_words_card]

  -- cylinders land inside the length-n universe
  have cylinder_subset_all_words_n (w : List Bool) (hw : w ∈ S) :
      cylinder w ⊆ all_words n := by
    intro x hx
    rcases Finset.mem_image.mp hx with ⟨s, hs, rfl⟩
    have hslen : s.length = n - w.length :=
      (mem_all_words_iff (n - w.length) s).1 hs
    have hwle : w.length ≤ n := by
      -- n = sup S length
      simpa [n] using (Finset.le_sup (s := S) (f := List.length) hw)
    have hlen : (w ++ s).length = n := by
      -- len(w++s) = len w + len s = w.length + (n - w.length) = n
      simp [List.length_append, hslen, Nat.add_sub_of_le hwle]
    exact (mem_all_words_iff n (w ++ s)).2 hlen

  -- now the main inequality
  have h_sum_le_total : ∑ w ∈ S, 2^(n - w.length) ≤ 2^n := by
    let U : Finset (List Bool) := S.biUnion cylinder
    have hU_card :
        U.card = ∑ w ∈ S, (cylinder w).card := by
      -- disjoint union → sum of cards
      simpa [U] using
        (Finset.card_biUnion (s := S) (t := cylinder)
          (by
            intro w1 hw1 w2 hw2 hne
            exact h_disjoint w1 hw1 w2 hw2 hne))
    have hU_sub : U ⊆ all_words n := by
      intro x hx
      rcases Finset.mem_biUnion.mp hx with ⟨w, hwS, hxw⟩
      exact cylinder_subset_all_words_n w hwS hxw
    have hU_le : U.card ≤ (all_words n).card :=
      Finset.card_le_card hU_sub
    -- rewrite sums into cards, then bound by all_words n
    calc
      ∑ w ∈ S, 2^(n - w.length)
          = ∑ w ∈ S, (cylinder w).card := by
              refine Finset.sum_congr rfl (fun w hw => ?_)
              simp [cylinder_card]
      _ = U.card := by simp [hU_card]
      _ ≤ (all_words n).card := hU_le
      _ = 2^n := by simp [all_words_card]

  -- Key algebra lemma: 2^(n-|w|)/2^n = (1/2)^{|w|}
  have rhs_eq (w : List Bool) (hw : w ∈ S) :
      (2 : ℝ)^(n - w.length) / (2 : ℝ)^n = (1/2 : ℝ)^w.length := by
    have hwle : w.length ≤ n := by
      -- n = sup lengths, so |w| ≤ n
      simpa [n] using (Finset.le_sup (s := S) (f := List.length) hw)
    have ha : (2 : ℝ)^(n - w.length) ≠ 0 := by positivity
    calc
      (2 : ℝ)^(n - w.length) / (2 : ℝ)^n
          = (2 : ℝ)^(n - w.length) / (2 : ℝ)^((n - w.length) + w.length) := by simp [Nat.sub_add_cancel hwle]
      _ = (2 : ℝ)^(n - w.length) / ((2 : ℝ)^(n - w.length) * (2 : ℝ)^(w.length)) := by simp [pow_add]
      _ = 1 / (2 : ℝ)^(w.length) := by
              -- x/(x*y) = (x/x)/y = 1/y
              calc
                (2 : ℝ)^(n - w.length) / ((2 : ℝ)^(n - w.length) * (2 : ℝ)^(w.length))
                    = ((2 : ℝ)^(n - w.length) / (2 : ℝ)^(n - w.length)) / (2 : ℝ)^(w.length) := by simp [div_mul_eq_div_div]
                _ = 1 / (2 : ℝ)^(w.length) := by simp [ha]
      _ = (1 / (2 : ℝ))^(w.length) := by simp
      _ = (1/2 : ℝ)^(w.length) := by simp

  -- Cast the Nat inequality to ℝ in the exact form we need
  have h_sum_le_totalR :
      (∑ w ∈ S, (2 : ℝ)^(n - w.length)) ≤ (2 : ℝ)^n := by
    have h_cast :
        ((∑ w ∈ S, 2^(n - w.length)) : ℝ) ≤ (2^n : ℕ) := by
      exact_mod_cast h_sum_le_total
    simpa [Nat.cast_sum, Nat.cast_pow, Nat.cast_two] using h_cast

  -- Final
  calc
    ∑ w ∈ S, (1/2 : ℝ)^w.length
        = ∑ w ∈ S, (2 : ℝ)^(n - w.length) / (2 : ℝ)^n := by
            refine Finset.sum_congr rfl (fun w hw => ?_)
            simpa using (rhs_eq w hw).symm
    _ = (∑ w ∈ S, (2 : ℝ)^(n - w.length)) / (2 : ℝ)^n := by
            simpa using
              (Finset.sum_div (s := S)
                (f := fun w => (2 : ℝ)^(n - w.length))
                (a := (2 : ℝ)^n)).symm
    _ ≤ (2 : ℝ)^n / (2 : ℝ)^n := by
            exact div_le_div_of_nonneg_right h_sum_le_totalR (by positivity)
    _ = 1 := by simp

/-
If a list of natural numbers is sorted non-decreasingly and the sum of $2^{-x}$ is at least 1, then there is a prefix whose sum is exactly 1.
-/
lemma exists_prefix_sum_eq_one_of_sorted {l : List ℕ} (h_sorted : l.Pairwise (· ≤ ·))
    (h_sum : (l.map (fun x => (1 / 2 : ℝ) ^ x)).sum ≥ 1) :
    ∃ l', l' <+: l ∧ (l'.map (fun x => (1 / 2 : ℝ) ^ x)).sum = 1 := by
  -- Let $k$ be the smallest index such that $s_k \geq 1$.
  obtain ⟨k, hk⟩ : ∃ k : ℕ, k ≤ l.length ∧ (∑ i ∈ Finset.range k, (1 / 2 : ℝ) ^ l[i]!) ≥ 1 ∧ ∀ j < k, (∑ i ∈ Finset.range j, (1 / 2 : ℝ) ^ l[i]!) < 1 := by
    have h_exists_k : ∃ k : ℕ, k ≤ l.length ∧ (∑ i ∈ Finset.range k, (1 / 2 : ℝ) ^ l[i]!) ≥ 1 := by
      use l.length
      convert h_sum.le using 1
      norm_num [ Finset.sum_range ]
    exact ⟨ Nat.find h_exists_k, Nat.find_spec h_exists_k |>.1, Nat.find_spec h_exists_k |>.2, fun j hj => not_le.1 fun h => Nat.find_min h_exists_k hj ⟨ Nat.le_trans ( Nat.le_of_lt hj ) ( Nat.find_spec h_exists_k |>.1 ), h ⟩ ⟩
  -- Let $M$ be the integer such that $s_{k-1} = M / 2^{l_k}$.
  obtain ⟨M, hM⟩ : ∃ M : ℕ, (∑ i ∈ Finset.range (k - 1), (1 / 2 : ℝ) ^ l[i]!) = M / 2 ^ l[k - 1]! := by
    -- Since $l$ is sorted non-decreasingly, we have $l[i] \leq l[k-1]$ for all $i < k-1$.
    have h_le : ∀ i < k - 1, l[i]! ≤ l[k - 1]! := by
      intro i hi
      have := List.pairwise_iff_get.mp h_sorted
      convert this ⟨ i, by linarith [ Nat.sub_le k 1 ] ⟩ ⟨ k - 1, by omega ⟩ ( Nat.lt_of_le_of_lt ( Nat.le_refl _ ) hi )
      · grind
      · grind
    -- Since $l[i] \leq l[k-1]$ for all $i < k-1$, we can write each term $(1 / 2)^{l[i]!}$ as $(1 / 2)^{l[k-1]!} \cdot 2^{l[k-1]! - l[i]!}$.
    have h_term : ∀ i < k - 1, (1 / 2 : ℝ) ^ l[i]! = (1 / 2 : ℝ) ^ l[k - 1]! * 2 ^ (l[k - 1]! - l[i]!) := by
      intro i hi; rw [ show ( 1 / 2 : ℝ ) = ( 2⁻¹ : ℝ ) by norm_num, inv_pow ] ; rw [ ← Nat.add_sub_of_le ( h_le i hi ) ] ; ring
      norm_num [ mul_assoc, ← mul_pow ]
    rw [ Finset.sum_congr rfl fun i hi => h_term i ( Finset.mem_range.mp hi ) ]
    norm_num [ ← Finset.mul_sum _ _ _, div_eq_mul_inv ]
    exact ⟨ ∑ i ∈ Finset.range ( k - 1 ), 2 ^ ( l[k - 1]?.getD 0 - l[i]?.getD 0 ), by simp [ div_eq_mul_inv, mul_comm ] ⟩
  -- Since $s_{k-1} < 1$, we have $M < 2^{l_k}$, so $M \leq 2^{l_k} - 1$.
  have hM_le : M ≤ 2 ^ l[k - 1]! - 1 := by
    have := hk.2.2 ( k - 1 )
    rcases k with ( _ | k ) <;> norm_num at *
    exact Nat.le_sub_one_of_lt ( by rw [ ← @Nat.cast_lt ℝ ] ; push_cast; rw [ hM, div_lt_one ( by positivity ) ] at this; linarith )
  -- Now consider $s_k = s_{k-1} + (1/2)^{l_k} = (M + 1) / 2^{l_k}$.
  have hsk : (∑ i ∈ Finset.range k, (1 / 2 : ℝ) ^ l[i]!) = (M + 1) / 2 ^ l[k - 1]! := by
    rcases k <;> simp_all [Finset.sum_range_succ]
    · linarith
    · ring
  -- Since $s_k \geq 1$, we have $M + 1 \geq 2^{l_k}$.
  have hM_ge : M + 1 ≥ 2 ^ l[k - 1]! := by
    exact_mod_cast ( by rw [ hsk ] at hk; rw [ ge_iff_le ] at hk; rw [ le_div_iff₀ ( by positivity ) ] at hk; linarith : ( 2 : ℝ ) ^ l[k - 1]! ≤ M + 1 )
  -- Combining $M \leq 2^{l_k} - 1$ and $M + 1 \geq 2^{l_k}$, we get $M = 2^{l_k} - 1$.
  have hM_eq : M = 2 ^ l[k - 1]! - 1 := by
    exact eq_tsub_of_add_eq ( by linarith [ Nat.sub_add_cancel ( Nat.one_le_pow ( l[k - 1]! ) 2 zero_lt_two ) ] )
  -- Thus $s_k = (2^{l_k} - 1 + 1) / 2^{l_k} = 1$.
  have hsk_eq_one : (∑ i ∈ Finset.range k, (1 / 2 : ℝ) ^ l[i]!) = 1 := by
    rw [ hsk, hM_eq, Nat.cast_sub <| Nat.one_le_pow _ _ zero_lt_two ]
    norm_num
  refine' ⟨ l.take k, _, _ ⟩
  · exact List.take_prefix _ _
  · convert hsk_eq_one using 1
    have h_sum_eq : ∀ (l : List ℕ) (k : ℕ), k ≤ l.length → (∑ i ∈ Finset.range k, (1 / 2 : ℝ) ^ l[i]!) = (List.map (fun x => (1 / 2 : ℝ) ^ x) (List.take k l)).sum := by
      intros l k hk
      induction k with
      | zero => simp
      | succ k ih =>
        -- 1. Split the sum on the left (0 to k -> 0 to k-1 + k)
        rw [Finset.sum_range_succ]
        -- 2. Split the list on the right (take (k+1) -> take k ++ [l[k]])
        have h_take : l.take (k + 1) = l.take k ++ [l.get ⟨k, Nat.lt_of_succ_le hk⟩] := by
          simp_all
        rw [h_take, List.map_append, List.sum_append]
        -- 3. Use IH for the prefix
        rw [ih (Nat.le_of_succ_le hk)]
        -- 4. Prove the last terms are equal
        simp_all [lt_of_lt_of_le (Nat.lt_succ_self k) hk]
    rw [ h_sum_eq l k hk.1 ]

/-
If a multiset of natural numbers is a sub-multiset of the image of a function on a finite type, then there is a subset of the domain whose image is that multiset.
-/
lemma exists_subset_of_multiset_le_map {I : Type*} [Fintype I] [DecidableEq I] (f : I → ℕ) (m : Multiset ℕ)
    (h : m ≤ Multiset.map f Finset.univ.val) :
    ∃ S : Finset I, Multiset.map f S.val = m := by
  by_contra! h
  -- Since the multiset of values in $m$ is a sub-multiset of the image of $f$ on the universal set, we can construct the desired Finset $S$ by taking the union of the subsets of the domain corresponding to each value in $m$.
  have h_union : ∃ S : Finset I, Multiset.map f S.val = m := by
    have h_count : ∀ v ∈ m.toFinset, Multiset.count v m ≤ Finset.card (Finset.filter (fun i => f i = v) Finset.univ) := by
      intro v hv
      have h_card : Multiset.count v m ≤ Multiset.count v (Multiset.map f Finset.univ.val) := by
        exact Multiset.count_le_of_le _ ‹_›
      rw [ Multiset.count_map ] at h_card
      simpa [ eq_comm ] using h_card
    have h_union : ∃ S : Finset I, ∀ v ∈ m.toFinset, Finset.card (Finset.filter (fun i => f i = v) S) = Multiset.count v m := by
      have h_union : ∀ v ∈ m.toFinset, ∃ S_v : Finset I, S_v ⊆ Finset.filter (fun i => f i = v) Finset.univ ∧ Finset.card S_v = Multiset.count v m := by
        exact fun v hv => Finset.exists_subset_card_eq ( h_count v hv )
      choose! S hS₁ hS₂ using h_union
      use Finset.biUnion m.toFinset S
      intro v hv
      rw [ ← hS₂ v hv ]
      rw [ Finset.card_eq_sum_ones ]
      rw [ Finset.card_eq_sum_ones ]
      rw [ Finset.sum_subset ]
      ·
        intro x hx
        -- 1. Unpack that x is in the biUnion and satisfies the filter (f x = v)
        simp only [Finset.mem_filter, Finset.mem_biUnion] at hx
        obtain ⟨⟨u, hu_m, hx_Su⟩, hfx⟩ := hx

        -- 2. Use the property that S u contains only elements mapping to u
        have hfu : f x = u := by
          -- hS₁ : S u ⊆ {i | f i = u}
          have := hS₁ u hu_m hx_Su
          simp only [Finset.mem_filter, Finset.mem_univ, true_and] at this
          exact this

        -- 3. Conclude u = v, therefore x ∈ S v
        simp_all
      · simp [ Finset.mem_biUnion ]
        exact fun x hx => ⟨ v, Multiset.mem_toFinset.mp hv, hx, Finset.mem_filter.mp ( hS₁ v hv hx ) |>.2 ⟩
    obtain ⟨ S, hS ⟩ := h_union
    use S.filter (fun i => f i ∈ m)
    ext v
    by_cases hv : v ∈ m <;> simp_all [ Multiset.count_map ]
    · convert hS v hv using 1
      exact congr_arg Finset.card (Finset.filter_congr fun x hx => by
        apply Iff.intro
        · intro a
          simp_all only
        · intro a
          subst a
          simp_all only [and_self]
      )
    · intro a a_1 a_2
      subst a_2
      exact hv
  exact h _ h_union.choose_spec

/-
Let $I$ be a finite set and let $\ell\colon I \to \mathbb{N}$ satisfy $\sum_{i \in I} 2^{-\ell(i)} \geq 1$. There exists a subset $S \subseteq I$ such that $\sum_{i \in S} 2^{-\ell(i)} = 1$.
-/
lemma exists_subset_sum_eq_one {I : Type*} [Fintype I] [DecidableEq I] (l : I → ℕ)
    (h_sum : 1 ≤ ∑ i, (1 / 2 : ℝ) ^ l i) :
    ∃ S : Finset I, ∑ i ∈ S, (1 / 2 : ℝ) ^ l i = 1 := by
  -- Let $n = |I|$ and let $\ell'_1,\dots,\ell'_n$ consist of $(\ell(i))_{i \in I}$ arranged in nonincreasing order.
  set n := Fintype.card I
  obtain ⟨ℓ', hℓ'⟩ : ∃ ℓ' : Fin n → ℕ, Multiset.ofList (List.ofFn ℓ') = Multiset.map l Finset.univ.val := by
    -- Let $ℓ'$ be the list of values of $l$ on the elements of $I$.
    obtain ⟨ℓ', hℓ'⟩ : ∃ ℓ' : List ℕ, List.length ℓ' = n ∧ Multiset.ofList ℓ' = Multiset.map l Finset.univ.val := by
      use Finset.univ.val.map l |> Multiset.toList
      simp_all [n]
    use fun i => ℓ'.get (i.cast hℓ'.1.symm) -- Cast the Fin n to a valid index for ℓ'
    convert hℓ'.2 using 2
    have h_len : (List.ofFn fun i : Fin n => ℓ'.get (i.cast hℓ'.1.symm)).length = ℓ'.length := by
      simp only [List.length_ofFn, hℓ'.1]
    refine' List.ext_get h_len _
    simp_all
  -- Apply `exists_prefix_sum_eq_one_of_sorted` to the sorted list.
  obtain ⟨l'', hl''⟩ : ∃ l'' : List ℕ, l''.Perm (List.ofFn ℓ') ∧ List.Pairwise (· ≤ ·) l'' ∧ (l''.map (fun x => (1 / 2 : ℝ) ^ x)).sum ≥ 1 := by
    refine' ⟨ List.ofFn ℓ' |> List.insertionSort ( · ≤ · ), _, _, _ ⟩
    · exact List.perm_insertionSort (fun x1 x2 ↦ x1 ≤ x2) (List.ofFn ℓ')
    · exact List.pairwise_insertionSort _ _
    · have h_sum_eq : (List.map (fun x => (1 / 2 : ℝ) ^ x) (List.ofFn ℓ')).sum = ∑ i, (1 / 2 : ℝ) ^ (l i) := by
        have h_sum_eq : (List.map (fun x => (1 / 2 : ℝ) ^ x) (List.ofFn ℓ')).sum = Multiset.sum (Multiset.map (fun x => (1 / 2 : ℝ) ^ x) (Multiset.ofList (List.ofFn ℓ'))) := by
          rfl
        simp_all
      have h_sum_eq : (List.map (fun x => (1 / 2 : ℝ) ^ x) (List.insertionSort (· ≤ ·) (List.ofFn ℓ'))).sum = (List.map (fun x => (1 / 2 : ℝ) ^ x) (List.ofFn ℓ')).sum := by
        have h_sum_eq : List.Perm (List.insertionSort (· ≤ ·) (List.ofFn ℓ')) (List.ofFn ℓ') := by
          exact List.perm_insertionSort (fun x1 x2 ↦ x1 ≤ x2) (List.ofFn ℓ')
        exact List.Perm.sum_eq ( h_sum_eq.map _ )
      linarith
  -- Apply `exists_prefix_sum_eq_one_of_sorted` to the sorted list `l''`.
  obtain ⟨l''', hl'''⟩ : ∃ l''' : List ℕ, l''' <+: l'' ∧ (l'''.map (fun x => (1 / 2 : ℝ) ^ x)).sum = 1 := by
    apply exists_prefix_sum_eq_one_of_sorted hl''.2.1 hl''.2.2
  -- The elements of this prefix correspond to a subset $S$ of $I$.
  obtain ⟨S, hS⟩ : ∃ S : Finset I, Multiset.map l S.val = Multiset.ofList l''' := by
    apply_rules [ exists_subset_of_multiset_le_map ]
    have h_subset : Multiset.ofList l''' ≤ Multiset.ofList l'' := by
      exact hl'''.1.sublist.subperm
    exact h_subset.trans ( by rw [ ← hℓ' ] ; exact Multiset.le_iff_exists_add.mpr ⟨ ∅, by simp [ hl''.1.symm ] ⟩ )
  replace hS := congr_arg ( fun m => Multiset.sum ( m.map fun x => ( 1 / 2 : ℝ ) ^ x ) ) hS ; aesop

/-
Let $I$ be a finite set and let $\ell\colon I \to \mathbb{N}$ satisfy $\sum_{i\in I} 2^{-\ell(i)} \leq 1$.
There exists an injective mapping $w \colon I \to \{0,1\}^*$ whose image is prefix-free, and furthermore $|w(i)| = \ell(i)$.
-/
theorem kraft_inequality_tight {I : Type*} [Fintype I] [DecidableEq I] (l : I → ℕ)
    (h : ∑ i, (1 / 2 : ℝ) ^ l i ≤ 1) :
    ∃ w : I → List Bool, (
      Function.Injective w
      ∧ PrefixFree (Finset.univ.image w)
      ∧ ∀ i, (w i).length = l i)
 := by
  by_contra h_contra
  -- Let $m = \max_{i \in I} \ell(i)$.
  let m : ℕ := Finset.univ.sup l
  -- We prove this by strong induction on $m$.
  have h_ind : ∀ m : ℕ, ∀ (I : Type _) [Fintype I] [DecidableEq I]
       (l : I → ℕ), (∀ i, l i ≤ m)
        → (∑ i, (1 / 2 : ℝ) ^ l i) ≤ 1
        → ∃ (w : I → (List Bool)),
          (Function.Injective w)
          ∧ PrefixFree (Finset.univ.image w)
          ∧ (∀ i, ((w i).length = (l i))) := by
    intro m
    induction' m with m ih
    · intro I _ _ l hl hsum
      by_cases hI : Nonempty I
      · simp_all
        interval_cases z : Fintype.card I <;> simp_all [ Fintype.card_eq_one_iff ]
        obtain ⟨w, h_1⟩ := z
        simp_all only [forall_const]
        apply Exists.intro
        · constructor
          · intro a₁ a₂ a
            simp_all only
          · constructor
            · intro x a y a_1 a_2
              simp_all
            · rfl
      · -- hI : ¬ Nonempty I
        haveI : IsEmpty I := ⟨fun i => hI ⟨i⟩⟩
        refine ⟨(fun i => (isEmptyElim i)), ?_, ?_, ?_⟩
        · intro a
          exact (isEmptyElim a)
        · intro x hx
          exact (False.elim (by
            -- since there are no elements, Finset.univ is empty; membership impossible
            simp at hx))
        · intro i
          exact (isEmptyElim i)
    · intro I _ _ l hl hsum
      by_cases h_exists_zero : ∃ i, l i = 0
      · obtain ⟨i₀, hi₀⟩ : ∃ i₀, l i₀ = 0 := h_exists_zero
        have h_card : Fintype.card I = 1 := by
          have h_card : ∑ i, (1 / 2 : ℝ) ^ l i ≥ 1 := by
            exact le_trans ( by norm_num [ hi₀ ] ) ( Finset.single_le_sum ( fun i _ => by positivity ) ( Finset.mem_univ i₀ ) )
          have h_card : ∑ i ∈ Finset.univ.erase i₀, (1 / 2 : ℝ) ^ l i = 0 := by
            norm_num +zetaDelta at *
            rw [ sub_eq_zero, hi₀, pow_zero ]
            linarith
          simp_all
          rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ i₀ ) ] at h_card
          exact le_antisymm ( le_of_not_gt fun h => absurd h_card <| ne_of_gt <| sub_pos_of_lt <| lt_add_of_le_of_pos ( by norm_num [ hi₀ ] ) <| Finset.sum_pos ( fun x hx => inv_pos.mpr <| pow_pos zero_lt_two _ ) <| Finset.card_pos.mp <| by simp [ Finset.card_sdiff, * ] ) ( Fintype.card_pos_iff.mpr ⟨ i₀ ⟩ )
        rw [ Fintype.card_eq_one_iff ] at h_card
        obtain ⟨ x, hx ⟩ := h_card
        use fun _ => List.replicate (l x) Bool.true
        simp [ Function.Injective, hx ]
        simp [PrefixFree]
      · -- If $\sum_{i \in I} 2^{-\ell(i)} \leq \frac{1}{2}$, then we can take $S = I$.
        by_cases h_sum_half : (∑ i, (1 / 2 : ℝ) ^ (l i)) ≤ 1 / 2
        · -- Define $\ell'\colon I \to \mathbb{N}$ by $\ell'(i) = \ell(i) - 1$.
          set l' : I → ℕ := fun i => l i - 1 with hl'_def
          -- By the induction hypothesis, there exists an injective mapping $w' \colon I \to \{0,1\}^*$ whose image is prefix-free, and furthermore $|w'(i)| = \ell'(i)$.
          obtain ⟨w', hw'_inj, hw'_prefix, hw'_length⟩ : ∃ (w' : I → (List Bool)), (Function.Injective w') ∧ (PrefixFree (Finset.univ.image w')) ∧ (∀ i, ((w' i).length = (l' i))) := by
            apply ih I l'
            · exact fun i => Nat.sub_le_of_le_add <| by linarith [ hl i ]
            · convert mul_le_mul_of_nonneg_left h_sum_half zero_le_two using 1 <;> norm_num [ pow_succ', Finset.mul_sum _ _ _ ]
              exact Finset.sum_congr rfl fun i _ => by rw [ show l i = l' i + 1 by rw [ Nat.sub_add_cancel ( Nat.pos_of_ne_zero fun hi => h_exists_zero ⟨ i, hi ⟩ ) ] ] ; ring
          use fun i => false :: w' i
          simp_all +decide [ Function.Injective, PrefixFree ]
          exact ⟨ hw'_inj, hw'_prefix, fun i => Nat.succ_pred_eq_of_pos ( Nat.pos_of_ne_zero ( h_exists_zero i ) ) ⟩
        · -- Otherwise, we can find a subset $S \subseteq I$ such that $\sum_{i \in S} 2^{-\ell(i)} = \frac{1}{2}$.
          obtain ⟨S, hS⟩ : ∃ S : Finset I, (∑ i ∈ S, (1 / 2 : ℝ) ^ (l i)) = 1 / 2 := by
            have h_subset : ∃ S : Finset I, (∑ i ∈ S, (1 / 2 : ℝ) ^ (l i - 1)) = 1 := by
              apply exists_subset_sum_eq_one
              have h_subset : ∑ i, (1 / 2 : ℝ) ^ (l i - 1) = 2 * ∑ i, (1 / 2 : ℝ) ^ (l i) := by
                rw [ Finset.mul_sum _ _ _ ]
                exact Finset.sum_congr rfl fun i _ => by rw [ show ( 1 / 2 : ℝ ) ^ ( l i - 1 ) = 2 * ( 1 / 2 : ℝ ) ^ l i by rw [ show ( 1 / 2 : ℝ ) ^ l i = ( 1 / 2 : ℝ ) ^ ( l i - 1 ) * ( 1 / 2 : ℝ ) by rw [ ← pow_succ, Nat.sub_add_cancel ( Nat.pos_of_ne_zero fun hi => h_exists_zero ⟨ i, hi ⟩ ) ] ] ; ring ]
              linarith
            obtain ⟨ S, hS ⟩ := h_subset
            use S
            convert congr_arg ( · * ( 1 / 2 : ℝ ) ) hS using 1 <;> norm_num [ Finset.sum_mul _ _ _ ]
            exact Finset.sum_congr rfl fun i hi => by rw [ ← pow_succ, Nat.sub_add_cancel ( Nat.pos_of_ne_zero fun hi' => h_exists_zero ⟨ i, hi' ⟩ ) ]
          -- Define $\ell'\colon I \to \mathbb{N}$ by $\ell'(i) = \ell(i) - 1$.
          set l' : I → ℕ := fun i => l i - 1 with hl'_def
          -- By the induction hypothesis, there exist injective maps $w_0\colon S \to \{0,1\}^*$ and $w_1\colon S^c \to \{0,1\}^*$ such that $w_0(S)$ and $w_1(S^c)$ are prefix-free; $|w_0(i)| = \ell'(i)$ for all $i \in S$; and $|w_1(i)| = \ell'(i)$ for all $i \in S^c$.
          obtain ⟨w0, hw0_inj, hw0_prefix, hw0_len⟩ : ∃ w0 : S → (List Bool), (Function.Injective w0) ∧ (PrefixFree (Finset.univ.image w0)) ∧ (∀ i, ((w0 i).length = (l' i))) := by
            apply ih
            · exact fun i => Nat.sub_le_of_le_add <| by linarith [ hl i ]
            · rw [ ← Finset.sum_coe_sort ] at *
              convert mul_le_mul_of_nonneg_left hS.le zero_le_two using 1 <;> norm_num [ pow_succ', ← mul_assoc, Finset.mul_sum _ _ _ ]
              exact Finset.sum_congr rfl fun x hx => by rw [ show l ( x : I ) = l' ( x : I ) + 1 from by rw [ Nat.sub_add_cancel ( Nat.pos_of_ne_zero fun hi => h_exists_zero ⟨ x, hi ⟩ ) ] ] ; ring

          obtain ⟨w1, hw1_inj, hw1_prefix, hw1_len⟩ : ∃ w1 : { x // x ∉ S } → (List Bool), (Function.Injective w1) ∧ (PrefixFree (Finset.univ.image w1)) ∧ (∀ i, ((w1 i).length = (l' i))) := by
            apply ih { x // x ∉ S } (fun i => l' i)
            · exact fun i => Nat.sub_le_of_le_add <| by linarith [ hl i ]
            · have h_sum_complement : ∑ i ∈ Finset.univ \ S, (1 / 2 : ℝ) ^ (l i) ≤ 1 / 2 := by
                norm_num at *; linarith
              have h_sum_complement : ∑ i ∈ Finset.univ \ S, (1 / 2 : ℝ) ^ (l i - 1) ≤ 1 := by
                have h_sum_complement : ∑ i ∈ Finset.univ \ S, (1 / 2 : ℝ) ^ (l i - 1) = 2 * ∑ i ∈ Finset.univ \ S, (1 / 2 : ℝ) ^ (l i) := by
                  rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rcases k : l i with ( _ | k ) <;> simp_all +decide [ pow_succ' ]
                linarith
              convert h_sum_complement using 1
              refine' Finset.sum_bij ( fun x _ => x ) _ _ _ _ <;> simp +decide
              exact fun _ _ => rfl
          -- Define $w\colon I \to \{0, 1\}^*$ by
          use fun i => if hi : i ∈ S then 0 :: w0 ⟨i, hi⟩ else 1 :: w1 ⟨i, hi⟩
          refine' ⟨ _, _, _ ⟩
          · intro i j hij
            by_cases hi : i ∈ S <;> by_cases hj : j ∈ S <;> simp +decide [ hi, hj ] at hij ⊢
            · exact Subtype.ext_iff.mp ( hw0_inj hij )
            · exact congr_arg Subtype.val ( hw1_inj hij )
          ·
            -- abbreviate the combined map (same as your `use fun i => if ...`)
            let w : I → List Bool :=
              fun i => if hi : i ∈ S then (0 :: w0 ⟨i, hi⟩) else (1 :: w1 ⟨i, hi⟩)

            -- goal: PrefixFree ↑(Finset.image w Finset.univ)
            -- unfold PrefixFree
            intro x hx y hy hxy

            -- move membership from Set-coe to Finset membership, so we can `mem_image` cleanly
            have hx' : x ∈ ((Finset.univ : Finset I).image w : Finset (List Bool)) := by
              simpa using hx
            rcases Finset.mem_image.mp hx' with ⟨i, hiU, rfl⟩

            have hy' : y ∈ ((Finset.univ : Finset I).image w : Finset (List Bool)) := by
              simpa using hy
            rcases Finset.mem_image.mp hy' with ⟨j, hjU, rfl⟩

            by_cases hi : i ∈ S <;> by_cases hj : j ∈ S
            · -- i∈S, j∈S
              -- reduce the prefix fact to the tails
              have hxy' : (0 :: w0 ⟨i, hi⟩) <+: (0 :: w0 ⟨j, hj⟩) := by
                simpa [w, hi, hj] using hxy
              rcases hxy' with ⟨t, ht⟩
              -- ht : 0 :: w0 j = (0 :: w0 i) ++ t
              have ht_tail : w0 ⟨i, hi⟩ <+: w0 ⟨j, hj⟩ := by
                refine ⟨t, ?_⟩
                -- strip the leading cons from ht
                have : 0 :: (w0 ⟨i, hi⟩ ++ t) = (0 :: w0 ⟨j, hj⟩) := by
                  simpa [List.cons_append] using ht
                exact (List.cons.inj this).2

              -- membership facts for hw0_prefix
              have mem_i : w0 ⟨i, hi⟩ ∈ (↑((Finset.univ : Finset (↥S)).image w0) : Set (List Bool)) := by
                have : w0 ⟨i, hi⟩ ∈ ((Finset.univ : Finset (↥S)).image w0 : Finset (List Bool)) :=
                  Finset.mem_image_of_mem w0 (by simp)
                simp
              have mem_j : w0 ⟨j, hj⟩ ∈ (↑((Finset.univ : Finset (↥S)).image w0) : Set (List Bool)) := by
                have : w0 ⟨j, hj⟩ ∈ ((Finset.univ : Finset (↥S)).image w0 : Finset (List Bool)) :=
                  Finset.mem_image_of_mem w0 (by simp)
                simp

              have tail_eq : w0 ⟨i, hi⟩ = w0 ⟨j, hj⟩ :=
                hw0_prefix _ mem_i _ mem_j ht_tail

              simp [w, hi, hj, tail_eq]

            · -- i∈S, j∉S : impossible (0 :: …) <+: (1 :: …)
              have hxy' : (0 :: w0 ⟨i, hi⟩) <+: (1 :: w1 ⟨j, hj⟩) := by
                simp [w, hi, hj] at hxy
              rcases hxy' with ⟨t, ht⟩
              -- ht : 1 :: w1 j = (0 :: w0 i) ++ t = 0 :: (w0 i ++ t)
              have : (1 : Bool) = 0 := by
                have : (1 :: w1 ⟨j, hj⟩) = 0 :: (w0 ⟨i, hi⟩ ++ t) := by
                  simp [List.cons_append] at ht
                exact (List.cons.inj this).1
              cases this

            · -- i∉S, j∈S : impossible (1 :: …) <+: (0 :: …)
              have hxy' : (1 :: w1 ⟨i, hi⟩) <+: (0 :: w0 ⟨j, hj⟩) := by
                simp [w, hi, hj] at hxy
              rcases hxy' with ⟨t, ht⟩
              have : (0 : Bool) = 1 := by
                have : (0 :: w0 ⟨j, hj⟩) = 1 :: (w1 ⟨i, hi⟩ ++ t) := by
                  simp [List.cons_append] at ht
                exact (List.cons.inj this).1
              cases this

            · -- i∉S, j∉S
              have hxy' : (1 :: w1 ⟨i, hi⟩) <+: (1 :: w1 ⟨j, hj⟩) := by
                simpa [w, hi, hj] using hxy
              rcases hxy' with ⟨t, ht⟩
              have ht_tail : w1 ⟨i, hi⟩ <+: w1 ⟨j, hj⟩ := by
                refine ⟨t, ?_⟩
                have : 1 :: (w1 ⟨i, hi⟩ ++ t) = (1 :: w1 ⟨j, hj⟩)  := by
                  simpa [List.cons_append] using ht
                exact (List.cons.inj this).2

              have mem_i : w1 ⟨i, hi⟩ ∈ (↑((Finset.univ : Finset {x // x ∉ S}).image w1) : Set (List Bool)) := by
                have : w1 ⟨i, hi⟩ ∈ ((Finset.univ : Finset {x // x ∉ S}).image w1 : Finset (List Bool)) :=
                  Finset.mem_image_of_mem w1 (by simp)
                simp
              have mem_j : w1 ⟨j, hj⟩ ∈ (↑((Finset.univ : Finset {x // x ∉ S}).image w1) : Set (List Bool)) := by
                have : w1 ⟨j, hj⟩ ∈ ((Finset.univ : Finset {x // x ∉ S}).image w1 : Finset (List Bool)) :=
                  Finset.mem_image_of_mem w1 (by simp)
                simp

              have tail_eq : w1 ⟨i, hi⟩ = w1 ⟨j, hj⟩ :=
                hw1_prefix _ mem_i _ mem_j ht_tail

              simp [w, hi, hj, tail_eq]
          ·
            have hpos (i : I) : 0 < l i :=
              Nat.pos_of_ne_zero (by intro h0; exact h_exists_zero ⟨i, h0⟩)

            intro i
            by_cases hi : i ∈ S
            · simp [hi, hw0_len, l', Nat.sub_add_cancel (hpos i)]
            · simp [hi, hw1_len, l', Nat.sub_add_cancel (hpos i)]

  let m : ℕ := (Finset.univ : Finset I).sup l
  have hlm : ∀ i : I, l i ≤ m := by
    intro i; exact Finset.le_sup (s := (Finset.univ : Finset I)) (f := l) (by simp)
  have : ∃ w: I → List Bool, Function.Injective w ∧ PrefixFree ↑((Finset.univ : Finset I).image w) ∧ ∀ i, (w i).length = l i :=
    h_ind m I l hlm h
  exact False.elim (h_contra this)

/-
A finite set $S$ of words is uniquely decodable if every $x \in \{0,1\}^*$ can be written in at most one way as $x = w_1 \ldots w_r$ (for any $r$), where $w_1,\dots,w_r \in S$.
-/
def UniquelyDecodable (S : Finset (List Bool)) : Prop :=
  ∀ (L1 L2 : List (List Bool)), (∀ w ∈ L1, w ∈ S) → (∀ w ∈ L2, w ∈ S) → L1.flatten = L2.flatten → L1 = L2

/-
If a code is uniquely decodable, it does not contain the empty string.
-/
lemma epsilon_not_mem_of_uniquely_decodable {S : Finset (List Bool)} (h : UniquelyDecodable S) :
    [] ∉ S := by
  have h_empty : ∀ x ∈ S, x ≠ [] := by
    intro x hx
    have := h
    specialize this [ x ] [ x, x ]
    simp_all
  exact fun h => h_empty _ h rfl

/-
If $S$ is uniquely decodable, then the concatenation map from $S^r$ to strings is injective.
-/
lemma uniquely_decodable_extension_injective {S : Finset (List Bool)} (h : UniquelyDecodable S) (r : ℕ) :
    Function.Injective (fun (w : Fin r → S) => (List.ofFn (fun i => (w i).val)).flatten) := by
  -- Assume two functions w1 and w2 map to the same flattened list. We need to show w1 = w2.
  intro w1 w2 h_eq
  -- 1. Use Unique Decodability to show the lists of words are equal
  have h_lists : List.ofFn (fun i => (w1 i).val) = List.ofFn (fun i => (w2 i).val) := by
    apply h
    · simp only [List.mem_ofFn, forall_exists_index, forall_apply_eq_imp_iff]
      intro i
      exact (w1 i).2
    · simp only [List.mem_ofFn, forall_exists_index, forall_apply_eq_imp_iff]
      intro i
      exact (w2 i).2
    · exact h_eq

  -- 2. List equality implies pointwise equality of values
  have h_vals : (fun i => (w1 i).val) = (fun i => (w2 i).val) :=
    List.ofFn_injective h_lists
  -- 3. Pointwise equality of values implies equality of functions
  funext i
  apply Subtype.ext
  simpa using congrArg (fun f => f i) h_vals

/-
If $S$ is uniquely decodable, then $(\sum_{w \in S} 2^{-|w|})^r \le r \ell$.
-/
lemma kraft_mcmillan_inequality_aux (S : Finset (List Bool)) (h : UniquelyDecodable S) (r : ℕ) (hr : r ≥ 1) :
    (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length) ^ r ≤ r * (Finset.sup S List.length) := by
  -- Let $\ell = \max_{w \in S} |w|$.
  set ℓ := (S.sup List.length) with hℓ_def
  -- By definition of $C$, we have $C^r = \sum_{w_1,\dots,w_r \in S} 2^{-|w_1 \cdots w_r|}$.
  have h_sum : (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length) ^ r = ∑ w : Fin r → S, (1 / 2 : ℝ) ^ ((List.ofFn (fun i => (w i).val)).flatten.length) := by
    rw [ show ( ∑ w ∈ S, ( 1 / 2 : ℝ ) ^ w.length ) ^ r = ∑ w : Fin r → S, ∏ i : Fin r, ( 1 / 2 : ℝ ) ^ ( w i |> Subtype.val |> List.length ) from ?_ ]
    · norm_num [ List.length_flatten, Finset.prod_pow_eq_pow_sum ]
      norm_num [ List.sum_ofFn ]
    · rw [ ← Fin.prod_const, Finset.prod_sum ]
      refine' Finset.sum_bij _ _ _ _ _
      use fun a ha i => ⟨ a i ( Finset.mem_univ i ), Finset.mem_pi.mp ha i ( Finset.mem_univ i ) ⟩
      · simp
      · simp [ funext_iff ]
      · exact fun b _ => ⟨ fun i _ => b i |>.1, Finset.mem_pi.mpr fun i _ => b i |>.2, rfl ⟩
      · simp_all
  -- Since the map $(w_1,\dots,w_r) \mapsto w_1 \cdots w_r$ is injective, the sum $\sum_{w_1,\dots,w_r \in S} 2^{-|w_1 \cdots w_r|}$ is at most $\sum_{s=r}^{r\ell} \sum_{x \in \{0,1\}^s} 2^{-|x|}$.
  have h_injective : ∑ w : Fin r → S, (1 / 2 : ℝ) ^ ((List.ofFn (fun i => (w i).val)).flatten.length) ≤ ∑ s ∈ Finset.Icc r (r * ℓ), ∑ x ∈ Finset.filter (fun x => x.length = s) (Finset.image (fun w : Fin r → S => (List.ofFn (fun i => (w i).val)).flatten) (Finset.univ : Finset (Fin r → S))), (1 / 2 : ℝ) ^ x.length := by
    rw [ ← Finset.sum_biUnion ]
    · refine' le_of_eq _
      refine' Finset.sum_bij ( fun w hw => ( List.ofFn fun i => ( w i : List Bool ) ).flatten ) _ _ _ _ <;> simp +decide
      · simp +zetaDelta at *
        intro a
        exact ⟨ by rw [ List.sum_ofFn ] ; exact le_trans ( by norm_num ) ( Finset.sum_le_sum fun _ _ => Nat.one_le_iff_ne_zero.mpr <| by specialize h ; have := h ( [ ( a ‹_› : List Bool ) ] ) [ ] ; simp_all ), by rw [ List.sum_ofFn ] ; exact le_trans ( Finset.sum_le_sum fun _ _ => show List.length ( a _ : List Bool ) ≤ S.sup List.length from Finset.le_sup ( f := List.length ) <| by simp_all ) <| by norm_num ⟩
      · intro a₁ a₂ h_eq
        have := @uniquely_decodable_extension_injective S h r
        exact this h_eq
    · exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z => by simp_all
  -- Since $\sum_{x \in \{0,1\}^s} 2^{-|x|} = 1$ for any $s$, we have $\sum_{s=r}^{r\ell} \sum_{x \in \{0,1\}^s} 2^{-|x|} = \sum_{s=r}^{r\ell} 1 = r\ell - r + 1 \le r\ell$.
  have h_sum_one : ∀ s ∈ Finset.Icc r (r * ℓ), ∑ x ∈ Finset.filter (fun x => x.length = s) (Finset.image (fun w : Fin r → S => (List.ofFn (fun i => (w i).val)).flatten) (Finset.univ : Finset (Fin r → S))), (1 / 2 : ℝ) ^ x.length ≤ 1 := by
    intros s hs
    have h_card : Finset.card (Finset.filter (fun x => x.length = s) (Finset.image (fun w : Fin r → S => (List.ofFn (fun i => (w i).val)).flatten) (Finset.univ : Finset (Fin r → S)))) ≤ 2 ^ s := by
      have h_card : Finset.card (Finset.filter (fun x => x.length = s) (Finset.image (fun w : Fin r → S => (List.ofFn (fun i => (w i).val)).flatten) (Finset.univ : Finset (Fin r → S)))) ≤ Finset.card (Finset.image (fun x : Fin s → Bool => List.ofFn x) (Finset.univ : Finset (Fin s → Bool))) := by
        refine Finset.card_le_card ?_
        simp [ Finset.subset_iff ]
        intro a ha
        -- S : Finset (List Bool)
        -- h : UniquelyDecodable ↑S
        -- r : ℕ
        -- hr : r ≥ 1
        -- ℓ : ℕ := S.sup List.length
        -- hℓ_def : ℓ = S.sup List.length
        -- h_sum : (∑ w ∈ S, (1 / 2) ^ w.length) ^ r = ∑ w, (1 / 2) ^ (List.ofFn fun i ↦ ↑(w i)).flatten.length
        -- h_injective : ∑ w, (1 / 2) ^ (List.ofFn fun i ↦ ↑(w i)).flatten.length ≤
        --   ∑ s ∈ Finset.Icc r (r * ℓ),
        --     ∑ x ∈ Finset.image (fun w ↦ (List.ofFn fun i ↦ ↑(w i)).flatten) Finset.univ with x.length = s, (1 / 2) ^ x.length
        -- s : ℕ
        -- hs : s ∈ Finset.Icc r (r * ℓ)
        -- a : Fin r → ↥S
        -- ha : (List.ofFn (List.length ∘ fun i ↦ ↑(a i))).sum = s
        -- ⊢ ∃ a_1, List.ofFn a_1 = (List.ofFn fun i ↦ ↑(a i)).flatten
        sorry
      exact h_card.trans ( Finset.card_image_le.trans ( by norm_num [ Finset.card_univ ] ) )
    refine' le_trans ( Finset.sum_le_sum fun x hx => _ ) _
    use fun x => ( 1 / 2 ) ^ s
    · simp_all
    · norm_num at *
      exact le_trans ( mul_le_mul_of_nonneg_right ( Nat.cast_le.mpr h_card ) ( by positivity ) ) ( by rw [ ← mul_comm ] ; norm_num [ ← mul_pow ] )
  refine le_trans h_sum.le <| h_injective.trans <| le_trans ( Finset.sum_le_sum h_sum_one ) ?_
  rcases r with ( _ | _ | r ) <;> rcases ℓ with ( _ | _ | ℓ ) <;> norm_num at *
  · positivity
  · rw [ Nat.cast_sub ] <;> push_cast <;> nlinarith only [ hℓ_def ]

/-
If $S$ is a finite uniquely decodable code then $\sum_{w \in S} 2^{-|w|} \leq 1$.
-/
theorem kraft_mcmillan_inequality (S : Finset (List Bool)) (h : UniquelyDecodable S) :
    ∑ w ∈ S, (1 / 2 : ℝ) ^ w.length ≤ 1 := by
  -- Apply the Kraft-McMillan inequality.
  have h_kraft : ∀ r : ℕ, r ≥ 1 → (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length) ^ r ≤ r * (Finset.sup S List.length) := by
     exact fun r a ↦ kraft_mcmillan_inequality_aux S h r a
  contrapose! h_kraft
  -- Since $\sum_{w \in S} 2^{-|w|} > 1$, we can choose $r$ large enough such that $(\sum_{w \in S} 2^{-|w|})^r > r \cdot \ell$.
  have hr_exists : Filter.Tendsto (fun r : ℕ => (r * (Finset.sup S List.length) : ℝ) / (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length) ^ r) Filter.atTop (nhds 0) := by
    -- We can factor out $r$ and use the fact that $(\sum_{w \in S} 2^{-|w|})^r$ grows exponentially.
    have hr_factor : Filter.Tendsto (fun r : ℕ => (r : ℝ) / (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length) ^ r) Filter.atTop (nhds 0) := by
      -- We can convert this limit into a form that is easier to handle by substituting $y = r \log(\sum_{w \in S} 2^{-|w|})$.
      suffices h_log : Filter.Tendsto (fun y : ℝ => y / Real.exp y) Filter.atTop (nhds 0) by
        have h_subst : Filter.Tendsto (fun r : ℕ => (r * Real.log (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length)) / Real.exp (r * Real.log (∑ w ∈ S, (1 / 2 : ℝ) ^ w.length))) Filter.atTop (nhds 0) := by
          exact h_log.comp <| tendsto_natCast_atTop_atTop.atTop_mul_const <| Real.log_pos h_kraft
        convert h_subst.div_const ( Real.log ( ∑ w ∈ S, ( 1 / 2 ) ^ w.length ) ) using 2 <;> norm_num [ Real.exp_nat_mul, Real.exp_log ( zero_lt_one.trans h_kraft ) ] ; ring
        rw [ mul_assoc, mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos h_kraft ) ), mul_one ]
      simpa [ Real.exp_neg ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 1
    simpa [ mul_div_right_comm ] using hr_factor.mul_const _
  exact Filter.eventually_atTop.mp ( hr_exists.eventually ( gt_mem_nhds zero_lt_one ) ) |> fun ⟨ r, hr ⟩ ↦ ⟨ r + 1, by linarith, by have := hr ( r + 1 ) ( by linarith ) ; rw [ div_lt_iff₀ ( by positivity ) ] at this; linarith ⟩

/-
If a finite set $S$ of words is prefix-free and $\epsilon \notin S$ then it is uniquely decodable.
-/
theorem prefix_free_is_uniquely_decodable (S : Finset (List Bool)) (h : PrefixFree S) (h_eps : [] ∉ S) :
    UniquelyDecodable S := by
  -- We prove by strong induction on $|x|$ that every word $x \in \{0,1\}^*$ can be written in at most one way as $x = w_1 \dots w_r$ (for any $r$), where $w_1,\dots,w_r \in S$.
  have h_induction : ∀ x : List Bool, ∀ L1 L2 : List (List Bool), (∀ w ∈ L1, w ∈ S) → (∀ w ∈ L2, w ∈ S) → L1.flatten = L2.flatten → L1 = L2 := by
    intros x L1 L2 hL1 hL2 hflatten
    induction' L1 with w1 L1 ih generalizing L2
    · induction L2 <;> simp_all
    · rcases L2 with ( _ | ⟨ x, L2 ⟩ ) <;> simp_all +decide [ List.flatten ]
      -- Since $w1$ and $x$ are both in $S$ and $S$ is prefix-free, we must have $w1 = x$.
      have hw1_eq_x : x = w1 := by
        have := h _ hL1.1 _ hL2.1
        have := h _ hL2.1 _ hL1.1
        rw [ List.append_eq_append_iff ] at hflatten
        -- Try these:
        --   [apply] grind only [usr List.prefix_append, #0770]
        --   [apply] grind only [usr List.prefix_append]
        --   [apply] grind => cases #0770 <;> instantiate only [usr List.prefix_append]
        -- Since w1 and x are both in S and S is prefix-free, we must have w1 = x.
        -- 1. Use the append lemma to split into cases
        grind?
      simp_all only [true_and, List.append_cancel_left_eq]
      apply ih
      · intro w a
        simp_all only
      · simp_all only
  exact fun L1 L2 h1 h2 h3 => h_induction ( L1.flatten ) L1 L2 h1 h2 h3

/-
If a finite set $S$ of words is prefix-free and $|S| \geq 2$ then it is uniquely decodable.
-/
theorem prefix_free_is_uniquely_decodable_of_card_ge_two (S : Finset (List Bool)) (h : PrefixFree S) (h_card : S.card ≥ 2) :
    UniquelyDecodable S := by
  have h_eps_not_mem : []∉ S := by
    exact fun h0 => by obtain ⟨ w, hw, hw' ⟩ := Finset.exists_of_ssubset ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.singleton_subset_iff.mpr h0, by aesop_cat ⟩ ) ; specialize h _ h0 _ hw ; aesop
  exact prefix_free_is_uniquely_decodable S h h_eps_not_mem

/-
If $S$ is a (possibly infinite) prefix-free code then $\sum_{w \in S} 2^{-|w|} \leq 1$.
-/
theorem kraft_inequality_infinite (S : Set (List Bool)) (h : PrefixFree S) :
    HasSum (fun w : S => (1 / 2 : ℝ) ^ (w : List Bool).length) (∑' w : S, (1 / 2 : ℝ) ^ (w : List Bool).length) ∧
    (∑' w : S, (1 / 2 : ℝ) ^ (w : List Bool).length) ≤ 1 := by
  -- Let $F$ be any finite subset of $S$. Then $F$ is prefix-free. By the finite Kraft inequality, $\sum_{w \in F} 2^{-|w|} \le 1$.
  have h_finite_subset : ∀ (F : Finset (List Bool)), SetLike.coe F ⊆ S → (∑ w ∈ F, (1 / 2 : ℝ) ^ w.length) ≤ 1 := by
    -- Apply the finite Kraft inequality to the finite subset F.
    intro F hF
    apply kraft_inequality F (by
    exact fun x hx y hy hxy => h x ( hF hx ) y ( hF hy ) hxy)
  refine' ⟨ _, _ ⟩
  · have h_summable : Summable (fun w : S => (1 / 2 : ℝ) ^ w.val.length) := by
      refine' summable_of_sum_le _ _
      exact 1
      · exact fun _ => by positivity
      · intro u
        specialize h_finite_subset ( u.image Subtype.val )
        simp_all
    exact h_summable.hasSum
  · contrapose! h_finite_subset
    -- Since the series is summable, there exists a finite subset $F$ of $S$ such that $\sum_{w \in F} 2^{-|w|} > 1$.
    obtain ⟨F, hF⟩ : ∃ F : Finset (↥S), (∑ w ∈ F, (1 / 2 : ℝ) ^ (w.val.length)) > 1 := by
      exact ( Summable.hasSum ( by exact ( by by_contra h; rw [ tsum_eq_zero_of_not_summable h ] at h_finite_subset; norm_num at h_finite_subset ) ) ) |> fun h => h.eventually ( lt_mem_nhds h_finite_subset ) |> fun h => h.exists
    use F.image Subtype.val
    simp_all

/-
If the series $\sum 2^{-l(i)}$ converges, then for any $k$, there are only finitely many $i$ such that $l(i) \le k$.
-/
lemma finite_le_of_summable {I : Type*} (l : I → ℕ)
    (h_summable : Summable (fun i => (1 / 2 : ℝ) ^ l i)) (k : ℕ) :
    {i | l i ≤ k}.Finite := by
  have := h_summable.hasSum.summable.tendsto_cofinite_zero; simp_all +decide
  -- Since $l(i) \leq k$, we have $(2 ^ l i)⁻¹ \geq (2 ^ k)⁻¹$.
  have h_bound : ∀ i : I, l i ≤ k → (2 ^ l i : ℝ)⁻¹ ≥ (2 ^ k : ℝ)⁻¹ := by
    exact fun i hi => inv_anti₀ ( by positivity ) ( pow_le_pow_right₀ ( by norm_num ) hi )
  exact Set.Finite.subset ( this.eventually ( gt_mem_nhds <| inv_pos.mpr <| pow_pos zero_lt_two k ) ) fun i hi => by aesop
